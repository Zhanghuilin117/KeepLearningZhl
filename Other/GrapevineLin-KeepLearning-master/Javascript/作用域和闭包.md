<!--
 * @Author: Yu
 * @Date: 2020-08-04 09:43:44
 * @LastEditTime: 2020-08-05 11:32:54
 * @FilePath: \KeepLearning\Javascript\作用域和闭包.md
 * @Description: ''
-->

## 作用域和闭包

1.  [理解词法作用域和动态作用域](https://github.com/mqyqingfeng/Blog/issues/3)

    > 1. 作用域是指程序源代码中定义变量的区域。
    > 2. 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
    > 3. JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。
    > 4. 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

2.  [理解 JavaScript 的作用域和作用域链](https://juejin.im/post/6844903797135769614)

    > JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。

    - **作用域和执行上下文之间最大的区别是**： 执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。

3)  理解 JavaScript 的执行[上下文栈](https://github.com/mqyqingfeng/Blog/issues/4)以及[变量对象](https://github.com/mqyqingfeng/Blog/issues/5)，可以应用堆栈信息快速定位问题

    - 函数调用栈其实就是执行上下文栈（Execution Context Stack）
    - JavaScript 的执行: 1.进入执行上下文 2.代码执行
    - **执行上下文**：当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。当进入执行上下文时，这时候还没有执行代码。
    - 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。
    - 变量对象会包括：

      1. 函数的所有形参 (如果是函数上下文)

         - 由名称和对应值组成的一个变量对象的属性被创建
         - 没有实参，属性值设为 undefined

      2. 函数声明

         - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
         - 如果变量对象已经存在相同名称的属性，则完全替换这个属性

      3. 变量声明

         - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
         - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性

    - [JavaScript 中的执行上下文和调用栈是什么？](https://juejin.im/entry/6844903492578967560)

4)  [this 的原理以及几种不同使用场景的取值](https://github.com/logan70/Blog/issues/27)

    - JavaScript 函数中 this 取值主要区分以下几个情况：

      1. 函数的普通调用
      2. 函数作为对象方法调用
      3. 函数作为构造函数调用
      4. 函数通过 call、apply、bind 间接调用
      5. 箭头函数的调用

    - **深入 this：**[从 ECMAScript 规范解读 this](https://github.com/mqyqingfeng/Blog/issues/7)

5)  闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

    - 闭包的概念：能够读取其他函数内部变量的函数。
    - 闭包的作用：访问函数内部变量、保持函数在环境中一直存在，不会被垃圾回收机制处理。
    - 闭包的优点：方便调用上下文中声明的局部变量；逻辑紧密，可以在一个函数中再创建个函数，避免了传参的问题。
    - 闭包的缺点：因为使用闭包，可以使函数在执行完后不被销毁，保留在内存中，如果大量使用闭包就会造成内存泄露，内存消耗很大。

6)  理解堆栈溢出和内存泄漏的原理，如何防止

    - 内存回收机制：引用计数、标记清除法
    - 内存泄漏：不再使用的内存区域没有被回收，导致这一块内存区域被白白浪费。
    - 堆栈溢出：调用栈入栈太多，出栈太慢，栈内存被占满，就会发生常见的堆栈溢出的错误，比如:

    ```javascript
    function foo() {
      foo();
    }
    foo();
    ```

    - [防止内存泄漏](http://www.ruanyifeng.com/blog/2017/04/memory-leak.html)：有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。ES6 考虑到了这一点，推出了两种新的数据结构：**WeakSet** 和 **WeakMap**。
    - [防止堆栈溢出](https://blog.csdn.net/aocucuan5035/article/details/101185718)

7)  [如何处理循环的异步操作](https://juejin.im/post/6844903599969927181)

8)  理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理
    - [浅析前端的模块化](https://juejin.im/post/6844903775002427399)
    - 模块化的好处：
      1. 避免命名冲突(减少命名空间污染)
      2. 更好的分离, 按需加载
      3. 更高复用性
      4. 高可维护性
    - Common.js 一般用于服务端，同步执行
    - AMD.js 异步加载
    - ES Module 现在使用较多，异步执行
